<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<!--Do not edit this autogenerated HTML file; edit src/xdocs files instead. --><html><head><META http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><style type="text/css"> @import url("style.css"); </style><title>Nux - Overview</title><meta name="author" content="Wolfgang Hoschek"><meta name="email" content="whoschek.AT.lbl.DOT.gov"></head><body bgcolor="#ffffff" text="#000000" link="#525D76" alink="#525D76" vlink="#525D76"><div class="text"><!--HEADER--><table border="0" width="100%" cellspacing="0" bgcolor="#ffffff"><tr><td width="33%" align="left">
			<a href="http://dsd.lbl.gov/nux">
				<img src="images/proj.jpg" border="0" alt="">
				
			</a>
		</td><td width="33%" align="center">
			<img src="images/proj-title.jpg" alt=""> 
		</td><td width="33%" align="right">
			<a href="http://www.lbl.gov">
				<img src="images/lbl-logo.gif" border="0" alt="">
			</a>
		</td></tr></table><!--TOP LINK MENU NAVIGATION--><div class="link"><table border="0" width="100%" cellpadding="0" cellspacing="0"><tr valign="baseline"><td align="left"><a href="./index.html" target="" title="Click to jump to Nux"><font color="#3366ff">Nux</font></a><a href="http://dsd.lbl.gov/sea/" target="" title="Click to jump to Sea"><font color="#3366ff">Sea</font></a><a href="http://dsd.lbl.gov/firefish/" target="" title="Click to jump to Firefish"><font color="#3366ff">Firefish</font></a><a href="http://dsd.lbl.gov/gtg/projects/pyGridWare/" target="" title="Click to jump to pyGridWare"><font color="#3366ff">pyGridWare</font></a><a href="http://www.bro-ids.org/" target="" title="Click to jump to Bro"><font color="#3366ff">Bro</font></a><a href="http://dsd.lbl.gov/NetLogger/" target="" title="Click to jump to NetLogger"><font color="#3366ff">NetLogger</font></a><a href="http://dsd.lbl.gov/P2P/file-share/" target="" title="Click to jump to Scishare"><font color="#3366ff">Scishare</font></a><a href="http://dsd.lbl.gov/~hoschek/colt" target="" title="Click to jump to Colt"><font color="#3366ff">Colt</font></a></td><td align="right"> Version 1.6 -  Last published Jun 18, 2006</td></tr></table></div><table border="0" width="100%" cellspacing="4"><tr><!--LEFT SIDE NAVIGATION--><td valign="top" align="left" nowrap="nowrap" class="leftcol" width="140"><div class="frame item"><div class="name">Software</div><div class="content"><a href="./index.html" target="">Home</a><a href="http://dsd.lbl.gov/nux-download" target="">Download</a><a href="./readme.html" target="">Readme</a><a href="./changelog.html" target="">Changelog</a><a href="./related.html" target="">FAQ / Related</a></div></div><div class="frame item"><div class="name">Development</div><div class="content"><a href="./dependencies.html" target="">Dependencies</a><a href="./api/index.html" target="">Javadoc API</a><a href="./mailing.html" target="">Mailing List</a><a href="./license.html" target="">License</a></div></div><div class="frame item"><div class="name">Research</div><div class="content"><a href="http://dsd.lbl.gov" target="">DSD Department</a></div></div><div class="frame item"><div class="name">Search</div><div class="content"><form action="http://www.google.com/search" method="get"><input type="hidden" name="as_sitesearch" value="dsd.lbl.gov"><input type="text" value="" size="13" maxLength="256" name="as_q"></form></div></div></td><!--LEFT SIDE SUBNAVIGATION--><!--RIGHT SIDE MAIN BODY--><td align="left" valign="top"><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Efficient and Powerful XML Processing Made Easy"><strong>Efficient and Powerful XML Processing Made Easy</strong></a></font></td></tr><tr><td><blockquote>
                 <p>
				Nux is an open-source Java toolkit making efficient and powerful XML processing easy.
				It is geared towards embedded use in 
				high-throughput XML messaging middleware such as large-scale Peer-to-Peer 
				infrastructures, message queues, publish-subscribe and matchmaking systems 
				for Blogs/newsfeeds, text chat, data acquisition and distribution systems, 
				application level routers, firewalls, classifiers, etc. 
                 </p>
				<p>
				Have you ever tried to take advantage of a robust and natural commodity Java tool set for 
				XML, XQuery, XPath, schema validation, binary XML, fuzzy fulltext similarity search and related technologies,
				yet were not ready to accept a significant performance penalty? Chances are most tool sets 
				turned out not to be particularly robust and natural, that they incurred dramatic penalties
				when used in straightforward manners, and that their complex idiosyncracies had a strong 
				tendency to distract from the real job and use cases you wanted to get done in a timely
				manner.
				</p>
				<p>				
				Nux helps to avoid XML nightmares, enabling you to mix and match powerful main-memory
				XML tools in natural, straightforward, seamless, 
				effective and standards compliant manners.
				</p>
				<p>				
				Nux reliably processes whatever data fits into main memory (even, say, 250 MB messages), 
				but it is not an XML database system, and does not attempt to be one.
				Nux integrates best-of-breed components, containing extensions of the 
				<a href="http://www.xom.nu/">XOM</a>,  
                 <a href="http://saxon.sourceforge.net/">Saxon</a> and
                 <a href="http://lucene.apache.org/java/docs/">Lucene</a> open-source libraries.
				</p>
				

				<table border="0" cellspacing="0" cellpadding="2" width="100%">
					<tr valign="top" class="table rowodd">
							<td class="table header" valign="top">Feature&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
							<td class="table header" valign="top">Summary</td>
							<td class="table header" valign="top">API</td>
						</tr><tr valign="top" class="table roweven">
							<td class="table row" valign="top">XQuery/XPath</td>
							<td class="table row" valign="top">
								Seamless, complete, standards compliant and efficient W3C XQuery and XPath support for XOM.
								Also see the <a href="api/nux/xom/tests/doc-files/fire-xquery-usage.txt ">nux/bin/fire-xquery</a> 
								command line test tool 
								and <a href="api/nux/xom/sandbox/XQueryBenchmark.html">XQueryBenchmark</a>.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/xquery/XQuery.html">API</a>
							</td>
						</tr><tr valign="top" class="table rowodd">
							<td class="table row" valign="top">In-place update</td>
							<td class="table row" valign="top">
								Simple yet powerful and efficient in-place <i>morphing </i> for use as an
								XQuery/XPath insert, update and delete facility; particularly useful for
								structurally small tree transformations without requiring (potentially
								huge) XML tree copies. 
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/xquery/XQueryUtil.html">API</a>
							</td>
						</tr><tr valign="top" class="table roweven">
							<td class="table row" valign="top">Fulltext search</td>
							<td class="table row" valign="top">
								Fulltext search (fuzzy similarity queries) for on-the-fly matchmaking
								in realtime streaming applications combining structured and unstructured queries.
								Arbitrary Lucene fulltext queries can be run from Java or 
								from XQuery/XPath/XSLT via a simple extension function.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/pool/FullTextUtil.html">API</a>
							</td>
						</tr><tr valign="top" class="table rowodd">
							<td class="table row" valign="top">Pooling</td>
							<td class="table row" valign="top">
								Efficient and flexible pools 
								and factories for documents, XQueries, XSL Transforms, as well as 
								document Builders that validate against various schema languages, including W3C XML Schemas, DTDs, RELAX NG, Schematron, etc.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/pool/package-summary.html">API</a>
							</td>
						</tr><tr valign="top" class="table roweven">
							<td class="table row" valign="top">Binary XML</td>
							<td class="table row" valign="top">
								Optional serialization and deserialization of XOM XML documents to and from
								an efficient and compact custom binary XML data format (<i>bnux</i>
								format), without loss or change of any information.
								Serialization and deserialization is much faster than with the standard textual XML format, 
								and the resulting binary data is more compressed than textual XML.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/binary/BinaryXMLCodec.html">API</a>
							</td>
						</tr><tr valign="top" class="table rowodd">
							<td class="table row" valign="top">Streaming XQuery</td>
							<td class="table row" valign="top">
								For simple and complex continuous queries and/or transformations over very 
								large or infinitely long XML input,
								a convenient streaming path filter API combines full XQuery and XPath support with 
								straightforward filtering.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/xquery/StreamingPathFilter.html">API</a>
							</td>
						</tr><tr valign="top" class="table roweven">
							<td class="table row" valign="top">Streaming Serialization</td>
							<td class="table row" valign="top">
								Using memory consumption close to zero, streaming serialization enables writing arbitrarily large XML documents 
								 onto a destination, such as an 
								<code>OutputStream</code>, both for standard textual XML as well as binary XML.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/io/StreamingSerializer.html">API</a>
							</td>
						</tr><tr valign="top" class="table rowodd">
							<td class="table row" valign="top">Pluggable SAX and StAX</td>
							<td class="table row" valign="top">
								A XOM Builder implementation that uses a StAX parser (e.g. <a href="http://woodstox.codehaus.org/">Woodstox</a>) 
								instead of a SAX parser (e.g. Xerces) can be used interchangeably.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/io/package-summary.html">API</a>
							</td>
						</tr><tr valign="top" class="table roweven">
							<td class="table row" valign="top">JAXB and HTML</td>
							<td class="table row" valign="top">
								Conversion from XOM to JAXB and vice-versa, serving as an intermediary for 
								XML &lt;--&gt; Object mapping tools. 
								XQueries over ill-formed HTML.
							</td>
							<td class="table row" valign="top">
								<a href="api/nux/xom/pool/XOMUtil.html">API</a>
							</td>
						</tr><tr valign="top" class="table rowodd">
							<td class="table row" valign="top">Open Source</td>
							<td class="table row" valign="top">BSD style license</td>
							<td class="table row" valign="top"></td>
						</tr>
				</table>
				
		</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Motivation"><strong>Motivation</strong></a></font></td></tr><tr><td><blockquote>
				<p>
				Have you ever tried to do queries and/or transformations over XML data sources?
				Chances are that manual SAX/DOM processing was cumbersome at best, that XPath was not powerful or flexible enough,
				or XSLT perhaps too complicated, and that most related APIs have a steep learning curve, and 
				contain quite a few bugs.
				</p>
				<p>				
				This is where the power and simplicity of XQuery comes in. 
				Nux provides seamless XQuery support for XOM, leveraging the 
				standards compliance, efficiency and maturity of the <a href="http://saxon.sourceforge.net/">Saxon</a> engine, 
				in combination with a robust, lean and mean adapter for XOM that Nux contributed to Saxon.
				Since XQuery is a superset of XPath 2.0 it
				can also be used with plain XPath expressions as queries.
				It implements W3C Candidate Recommendation, 3 November 2005 
				and passes several exhaustive test suites. 
				Like Saxon-B, Nux XQuery is not schema aware, unlike the commercial Saxon SA version.
				</p>
				<p>
				Have you ever tried to build an XML system that is straightforward, works correctly <i>and</i> 
				processes tens of thousands of small XML messages per second in non-trivial ways? Chances are you've encountered lots of 
				non-obvious obstacles down that path. For that scenario, Nux couples the simplicity and correctness qualities of XOM with 
				efficient and flexible pools 
				and factories for documents, XQueries, XSL Transforms, as well as 
				document Builders that validate against various schema languages, including
				W3C XML Schemas (leveraging <a href="http://xml.apache.org/xerces2-j/">Xerces</a>),
				RELAX NG, Schematron, etc. (leveraging <a href="http://msv.dev.java.net/">MSV</a>).
				</p>
				<p>
				For particularly stringent performance requirements
				an option for lightning-fast binary XML serialization and deserialization
				is offered. 
				XML &lt;--&gt; Object mapping glue for integration with 
				<a href="http://jaxb.dev.java.net/">JAXB</a> 
				and for queries over ill-formed HTML is also provided.
				</p>
		</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Architecture Overview / Technology Layers"><strong>Architecture Overview / Technology Layers</strong></a></font></td></tr><tr><td><blockquote>
<p>
In a nutshell, the involved technologies are layered as follows:
<p></p>
<img src="images/architecture.jpg" width="80%" alt="Technology layers">
</p>
</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Command Line Usage"><strong>Command Line Usage</strong></a></font></td></tr><tr><td><blockquote>
<p>
To get started, you can use 
<a href="api/nux/xom/tests/doc-files/fire-xquery-usage.txt ">nux/bin/fire-xquery</a>,
a flexible command line test tool that runs a given XQuery against a set of files 
and prints the result sequence. For example:

<div class="frame listing"><div class="name"><a name="List the titles of Tim Bray's blog articles via the Atom feed">List the titles of Tim Bray's blog articles via the Atom feed</a></div><div class="listingcontent">
fire-xquery --query='{declare namespace atom = "http://www.w3.org/2005/Atom"; 
    doc("http://www.tbray.org/ongoing/ongoing.atom")/atom:feed/atom:entry/atom:title}'
</div></div>

<p></p>

<div class="frame listing"><div class="name"><a name="Example Output">Example Output</a></div><div class="listingcontent">
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;nbextras.org&lt;/title&gt;
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;Election Day&lt;/title&gt;
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;Washington Post Screws Up&lt;/title&gt;
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;Marketing Truth&lt;/title&gt;
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;Upcoming Gig: JavaOne&lt;/title&gt;
&lt;title xmlns="http://www.w3.org/2005/Atom"&gt;GPL3 Draft&lt;/title&gt;
</div></div>

<p></p>

The command line tool also supports schema validation, XInclude (via XOM), 
an XQuery update facility, malformed HTML parsing (via TagSoup) and much more.
It's available for Unix and Windows, and works like any other decent Unix command line tool. 
The source code can be found in class <code>nux.xom.tests.XQueryCommand</code>.
</p>

</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Basic API Usage"><strong>Basic API Usage</strong></a></font></td></tr><tr><td><blockquote>
<p>
More interestingly, here are examples demonstrating basic API usage:
</p>

<div class="frame listing"><div class="name"><a name="Parsing, Constructing and Serializing a Document with XOM">Parsing, Constructing and Serializing a Document with XOM</a></div><div class="listingcontent">
  // parse a file document with XOM:
  Document doc = new Builder().build(new File("samples/data/periodic.xml"));
  System.out.println(doc.toXML());
  System.out.println(XOMUtil.toPrettyXML(doc));
  
  // parse a string document:
  String xml = 
    "&lt;foo&gt;" +
      "&lt;bar size='123'&gt;" +
        "hello world" +
      "&lt;/bar&gt;" +
    "&lt;/foo&gt;";
  Document doc = XOMUtil.toDocument(xml);
  System.out.println(doc.toXML());
  System.out.println(XOMUtil.toPrettyXML(doc));
  
  // construct a XOM document (main memory tree):
  Element bar = new Element("bar");
  bar.addAttribute(new Attribute("size", "123"));
  bar.appendChild(new Text("hello world"));
  Element foo = new Element("foo");
  foo.appendChild(bar);
  Document doc = new Document(foo);  
  System.out.println(doc.toXML());
  System.out.println(XOMUtil.toPrettyXML(doc));
  
  // serialize a document with XOM onto an OutputStream:
  OutputStream out = new FileOutputStream("samples/data/periodic2.xml");
  Serializer ser = new Serializer(out);
  // ser.setIndent(4); // optional pretty printing 
  ser.write(doc);
  out.close(); 
</div></div>
<p></p>
<div class="frame listing"><div class="name"><a name="Pluggable SAX and StAX parser">Pluggable SAX and StAX parser</a></div><div class="listingcontent">
  // parse a document with XOM, either using SAX or StAX:
  InputStream in = new FileInputStream("samples/data/articles.xml");
  boolean useSAX = true;
  // boolean useSAX = false;
  
  Builder builder = useSAX ? new Builder() : StaxUtil.createBuilder(null, null);
  
  Document doc = builder.build(in);
  System.out.println(doc.toXML());
</div></div>

</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="XPath / XQuery examples"><strong>XPath / XQuery examples</strong></a></font></td></tr><tr><td><blockquote>
<div class="frame listing"><div class="name"><a name="Basic XPath / XQuery examples">Basic XPath / XQuery examples</a></div><div class="listingcontent">
  // parse XML document with XOM:
  Document doc = new Builder().build(new File("samples/data/periodic.xml"));
  
  // find the atom named 'Zinc' in the periodic table:
  Node result = XQueryUtil.xquery(doc, "/PERIODIC_TABLE/ATOM[NAME = 'Zinc']").get(0);
  System.out.println("result=" + result.toXML());
 
  // equivalent via the more powerful underlying API:
  XQuery xquery = new XQuery("/PERIODIC_TABLE/ATOM[NAME = 'Zinc']", null);
  Node result = xquery.execute(doc).next();

  // count the numer of elements in a document tree
  int count = XQueryUtil.xquery(doc, "//*").size();
  System.out.println("count=" + count);
</div></div>
	
<p></p>						
<div class="frame listing"><div class="name"><a name="A query to find the links of all images (or all JPG images) in a XHTML-like document, with serialization to an output stream">A query to find the links of all images (or all JPG images) in a XHTML-like document, with serialization to an output stream</a></div><div class="listingcontent">
  Document doc = new Builder().build(new File("/tmp/test.xml"));
  Nodes results = XQueryUtil.xquery(doc, "//*:img/@src");
  //Nodes results = XQueryUtil.xquery(doc, "//*:img/@src[matches(., '.jpg')]");

  // see exactly what items the query does (or does not) return:
  for (int i=0; i &lt; results.size(); i++) {
     System.out.println("node "+i+": " + results.get(i).toXML());
     //System.out.println("node "+i+": " + XOMUtil.toPrettyXML(results.get(i)));
  }
  
  // or serialize results according to W3C spec onto an output stream:
  ResultSequenceSerializer ser = new ResultSequenceSerializer();
  ser.setEncoding("UTF-8");
  ser.setIndent(4);
  ser.setAlgorithm(ResultSequenceSerializer.W3C_ALGORITHM);
  // ser.setAlgorithm(ResultSequenceSerializer.WRAP_ALGORITHM);
  OutputStream out = System.out;
  ser.write(results, out);
</div></div>

<p></p>						
<div class="frame listing"><div class="name"><a name="More XQueries: List books published by Addison-Wesley after 1991,  including their year and title">More XQueries: List books published by Addison-Wesley after 1991,  including their year and title</a></div><div class="listingcontent">
  java:
  
  File query = new File("/tmp/saxonb-8.6.1/use-cases/xmp/q1.xq");
  XQuery xquery = XQueryPool.GLOBAL_POOL.getXQuery(query);
  Nodes results = xquery.execute(null).toNodes();
  ResultSequenceSerializer ser = new ResultSequenceSerializer();
  ser.setIndent(4);
  ser.write(results, System.out);

  xmp/q1.xq:

  &lt;bib&gt;
    {
      for $b in doc("bib.xml")/bib/book
      where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
      return
        &lt;book year="{ $b/@year }"&gt;
          { $b/title }
        &lt;/book&gt;
    }
  &lt;/bib&gt; 
  
  output:
  
  &lt;?xml version="1.0" encoding="UTF8"?&gt;
  &lt;bib&gt;
    &lt;book year="1994"&gt;
        &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;/book&gt;
    &lt;book year="1992"&gt;
        &lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
    &lt;/book&gt;
  &lt;/bib&gt;
</div></div>

<p></p>						
<div class="frame listing"><div class="name"><a name="A typical relational join XQuery that,  for all bicycles, lists the item number, description, and highest bid (if any),  ordered by item number">A typical relational join XQuery that,  for all bicycles, lists the item number, description, and highest bid (if any),  ordered by item number</a></div><div class="listingcontent">
  for $i in doc("items.xml")//item_tuple
  let $b := doc("bids.xml")//bid_tuple[itemno = $i/itemno]
  where contains($i/description, "Bicycle")
  order by $i/itemno
  return
      &lt;item_tuple&gt;
         { $i/itemno }
         { $i/description }
         &lt;high_bid&gt;{ max($b/bid) }&lt;/high_bid&gt;
      &lt;/item_tuple&gt;
</div></div>

</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Google-like realtime fulltext search via Apache Lucene engine"><strong>Google-like realtime fulltext search via Apache Lucene engine</strong></a></font></td></tr><tr><td><blockquote>
                Similar to Google search, the optional fulltext search via the Apache Lucene engine is 
                easy to use, powerful, efficient and goes far beyond what can be done with 
                standard XPath regular expressions 
                and string manipulation functions. It is similar in intent but not directly related to preliminary 
                <a target="_blank" href="http://www.w3.org/TR/xmlquery-full-text-use-cases">W3C fulltext search drafts</a>.
                Rather than targetting fulltext search of infrequent queries over huge persistent 
                data archives (historic search), Nux targets fulltext search of huge 
                numbers of queries over comparatively small transient realtime data (prospective search), 
                e.g. 100000-500000 queries/sec ballpark.
                See <a href="api/nux/xom/pool/FullTextUtil.html">FullTextUtil</a> and 
                <a href="api/org/apache/lucene/index/memory/package-summary.html">MemoryIndex</a>.
				<p>                
				
<div class="frame listing"><div class="name"><a name="Example fulltext XQuery that finds all books authored by James      that have something to do with 'salmon fishing manuals',      sorted by relevance">Example fulltext XQuery that finds all books authored by James      that have something to do with 'salmon fishing manuals',      sorted by relevance</a></div><div class="listingcontent">
declare namespace lucene = "java:nux.xom.pool.FullTextUtil";

declare variable $query := "+salmon~ +fish* manual~"; 
(: any arbitrary Lucene query can go here :)
(: declare variable $query as xs:string external; :)

for $book in /books/book[author="James" and lucene:match(abstract, $query) &gt; 0.0]
let $score := lucene:match($book/abstract, $query)
order by $score descending
return $book
</div></div>
				</p><p>
				
<div class="frame listing"><div class="name"><a name="Example fulltext XQuery that matches on extracted sentences">Example fulltext XQuery that matches on extracted sentences</a></div><div class="listingcontent">
declare namespace lucene = "java:nux.xom.pool.FullTextUtil";

for $book in /books/book
    for $s in lucene:sentences($book/abstract, 0)
        return
            if (lucene:match($s, "+salmon~ +fish* manual~") &gt; 0.0) 
            then normalize-space($s)
            else ()
</div></div>

				</p><p>
				Arbitrary Lucene fulltext queries can be run from Java or 
				from XQuery/XPath/XSLT via a simple extension function. 
				The former approach is more flexible whereas the latter is more convenient.				
				Lucene analyzers can split on whitespace, normalize to lower case
				for case insensitivity, ignore common terms with little 
				discriminatory value such as "he", "in", "and" (stop words), 
				reduce the terms to their natural linguistic root form such as 
				"fishing" being reduced to "fish" (stemming), resolve 
				synonyms/inflexions/thesauri (upon indexing and/or querying), etc.
				Also see <a target="_blank" href="http://lucene.apache.org/java/docs/queryparsersyntax.html">Lucene Query Syntax</a>
				as well as <a target="_blank" href="http://today.java.net/pub/a/today/2003/11/07/QueryParserRules.html">Query Parser Rules</a>.				
				
				</p><p>
				Explore and enjoy, perhaps using the queries and sample data from the 
				<code>samples/fulltext</code> directory as a starting point.
				</p> 
        </blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Querying Nasty HTML"><strong>Querying Nasty HTML</strong></a></font></td></tr><tr><td><blockquote>
<p>
If you'd like to query non-XML documents such as the typical HTML that lives out there,
you can combine Nux with <a href="http://www.tagsoup.info">TagSoup</a>,
which is a <i>"SAX-compliant parser that, instead of parsing well-formed or valid XML, 
parses HTML as it is found in the wild: nasty and brutish, though quite often far from short"</i>.
TagSoup plugs into XOM and makes ill-formed HTML appear as well-formed XML. 
Just add <code>tagsoup.jar</code> to the classpath and try this:
</p>

<div class="frame listing"><div class="name"><a name="XPath / XQuery with TagSoup">XPath / XQuery with TagSoup</a></div><div class="listingcontent">
  // find the links of all images in an ill-formed HTML document
  XMLReader parser = new org.ccil.cowan.tagsoup.Parser(); // tagsoup parser  
  Document doc = new Builder(parser).build("http://www.yahoo.com");
  Nodes results = XQueryUtil.xquery(doc, "//*:img/@src");

  for (int i=0; i &lt; results.size(); i++) {
     System.out.println("node "+i+": " + results.get(i).toXML());
     //System.out.println("node "+i+": " + XOMUtil.toPrettyXML(results.get(i)));
  }
</div></div>
</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Streaming Serialization of Very Large Documents"><strong>Streaming Serialization of Very Large Documents</strong></a></font></td></tr><tr><td><blockquote>
<p>
Using memory consumption close 
to zero, a <a href="api/nux/xom/io/StreamingSerializer.html">StreamingSerializer</a>
enables writing arbitrarily large XML documents onto a destination, such as an <code>OutputStream</code>, 
both for standard textual XML as well as binary XML.
</p>
<p>
Nodes should be written in document order, starting with
<code>writeXMLDeclaration()</code>, followed by writes for the individual nodes,
finally finishing with <code>writeEndDocument()</code>. Elements are opened and
closed via <code>writeStartTag(Element)</code> and <code>writeEndTag()</code>,
respectively.
</p>

<div class="frame listing"><div class="name"><a name="Creating a document with ten million records">Creating a document with ten million records</a></div><div class="listingcontent">
  StreamingSerializerFactory factory = new StreamingSerializerFactory();
  
  StreamingSerializer ser = factory.createXMLSerializer(System.out, "UTF-8");
  // StreamingSerializer ser = factory.createBinaryXMLSerializer(System.out, 0);
  // StreamingSerializer ser = factory.createStaxSerializer(XMLStreamWriter writer);
  
  ser.writeXMLDeclaration();
  ser.writeStartTag(new Element("articles"));
  for (int i = 0; i &lt; 10000000; i++) {
      Element article = new Element("article");
      article.addAttribute(new Attribute("id", String.valueOf(i)));
      ser.writeStartTag(article);
  
      ser.writeStartTag(new Element("prize"));
          ser.write(new Text(String.valueOf(i * 1000)));
      ser.writeEndTag(); // close prize
  
      ser.writeStartTag(new Element("quantity"));
          ser.write(new Text("hello world"));
      ser.writeEndTag(); // close quantity
  
      ser.writeEndTag(); // close article
  }
  ser.writeEndTag(); // close articles
  ser.writeEndDocument();
</div></div>
  
  <p>
  The following example demonstrates mixing streaming writes with convenient writing of entire
  prefabricated subtrees. For large documents, this approach combines the
  scalability advantages of streaming with the ease of use of (comparatively small)
  main-memory subtree construction:
  </p>
  
<div class="frame listing"><div class="name"><a name="Creating a document with ten million records, combining streaming with main-memory subtree construction">Creating a document with ten million records, combining streaming with main-memory subtree construction</a></div><div class="listingcontent">
  StreamingSerializerFactory factory = new StreamingSerializerFactory();
  
  StreamingSerializer ser = factory.createXMLSerializer(System.out, "UTF-8");
  // StreamingSerializer ser = factory.createBinaryXMLSerializer(System.out, 0);
  
  ser.writeXMLDeclaration();
  ser.writeStartTag(new Element("articles"));
  for (int i = 0; i &lt; 10000000; i++) {
     Element article = new Element("article");
     article.addAttribute(new Attribute("id", String.valueOf(i)));
  
     Element prize = new Element("prize");
         prize.appendChild(String.valueOf(i * 1000));
     article.appendChild(prize);
  
     Element quantity = new Element("quantity");
         quantity.appendChild("hello world");
     article.appendChild(quantity);
  
     ser.write(article); // writes entire subtree
  }
  ser.writeEndTag(); // close articles
  ser.writeEndDocument();
</div></div>

</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Streaming XQuery over Very Large Documents"><strong>Streaming XQuery over Very Large Documents</strong></a></font></td></tr><tr><td><blockquote>

<p>
Using the <a href="api/nux/xom/xquery/StreamingPathFilter.html">StreamingPathFilter</a>, 
the following example is complete and efficient code for parsing and iterating through millions of "person" 
records in a database-like XML document, printing all residents of "San Francisco", 
 while never allocating more memory than needed to hold one person element:
</p>

<div class="frame listing"><div class="name"><a name="Find and print all persons living in San Francisco">Find and print all persons living in San Francisco</a></div><div class="listingcontent">
  StreamingTransform myTransform = new StreamingTransform() {
      public Nodes transform(Element person) {
          Nodes results = XQueryUtil.xquery(person, 
              "name[../address/city = 'San Francisco']");
          if (results.size() &gt; 0) {
              System.out.println("name = " + results.get(0).getValue());
          }
          return new Nodes(); // mark element as subject to garbage collection
      }
  };
  
  // parse document with a filtering Builder
  NodeFactory factory = new StreamingPathFilter("/persons/person", null).
      createNodeFactory(null, myTransform);
  new Builder(factory).build(new File("/tmp/persons.xml"));
</div></div>

</blockquote></td></tr></table><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td bgcolor="#525D76"><font color="#ffffff"><a name="Working with Efficient Binary XML"><strong>Working with Efficient Binary XML</strong></a></font></td></tr><tr><td><blockquote>
<p>
The <a href="api/nux/xom/binary/BinaryXMLCodec.html">BinaryXMLCodec</a>
serializes (encodes) and deserializes (decodes) XOM XML documents to and from
an efficient and compact custom binary XML data format (termed <i>bnux </i>
format), without loss or change of any information. Serialization and
deserialization is much faster than with the standard textual XML format, and
the resulting binary data is more compressed than textual XML.
</p>

<div class="frame listing"><div class="name"><a name="Parse standard textual XML, convert to binary format, round-trip it and compare results">Parse standard textual XML, convert to binary format, round-trip it and compare results</a></div><div class="listingcontent">
  // parse standard textual XML with XOM
  Document doc = new Builder().build(new File("samples/data/periodic.xml"));
  
  // convert to binary XML
  BinaryXMLCodec codec = new BinaryXMLCodec();
  byte[] bnuxDoc = codec.serialize(doc, 0);
  
  // check correctness
  Document doc2 = codec.deserialize(bnuxDoc);
  boolean isEqual = java.util.Arrays.equals(
      XOMUtil.toCanonicalXML(doc), XOMUtil.toCanonicalXML(doc2));
  System.out.println("isEqual = " + isEqual);
  System.out.println(doc2.toXML());
  
  // write binary XML document to file
  OutputStream out = new FileOutputStream("/tmp/periodic.xml.bnux");
  out.write(bnuxDoc);
  out.close();
  
  // read binary XML document from file; convert to XOM document
  bnuxDoc = FileUtil.toByteArray(new FileInputStream("/tmp/periodic.xml.bnux"));
  Document doc3 = codec.deserialize(bnuxDoc);
  System.out.println(doc3.toXML());
</div></div>

<p></p>
<div class="frame listing"><div class="name"><a name="Streaming conversion of standard textual XML to and from binary format">Streaming conversion of standard textual XML to and from binary format</a></div><div class="listingcontent">
  // streaming conversion of standard textual XML to bnux binary XML:
  InputStream  in  = new FileInputStream("samples/data/weblog.xml");
  OutputStream out = new FileOutputStream("/tmp/weblog.xml.bnux");
  StreamingSerializerFactory factory = new StreamingSerializerFactory();
  StreamingSerializer serializer = factory.createBinaryXMLSerializer(out, 0);
  NodeFactory redirector = XOMUtil.getRedirectingNodeFactory(serializer);

  new Builder(redirector).build(in); // performs streaming conversion

  in.close();
  out.close();


  // streaming conversion of bnux binary XML to standard textual XML:
  InputStream  in  = new FileInputStream("/tmp/weblog.xml.bnux");
  OutputStream out = new FileOutputStream("/tmp/weblog.xml");
  StreamingSerializerFactory factory = new StreamingSerializerFactory();
  StreamingSerializer serializer = factory.createXMLSerializer(out, "UTF-8");
  NodeFactory redirector = XOMUtil.getRedirectingNodeFactory(serializer);

  new BinaryXMLCodec().deserialize(in, redirector); // performs streaming conversion

  in.close();
  out.close();		
</div></div>
</blockquote></td></tr></table></td><!--RIGHT SIDE NAVIGATION--></tr></table><!--FOOTER SEPARATOR--><hr noshade="noshade" size="1"><!--FOOTER--><table border="0" width="100%" cellspacing="0" bgcolor="#ffffff"><tr><td width="33%" align="left">
			<font color="#525D76" size="-1">
				<em><a href="mailto:wolfgang.hoschek.AT.mac.DOT.com">Contact us</a></em>
			</font>
		</td><td width="33%" align="center">
			<font color="#525D76" size="-1">
				<em>
					&copy; 2005, <a href="http://www.lbl.gov/">Lawrence Berkeley	National Laboratory</a>
				</em>
			</font>
			
			
		</td><td width="33%" align="right">
			<a href="http://validator.w3.org/check/referer"><img src="images/valid-html401.png" alt="Valid HTML 4.01!" width="88" height="31" border="0"> </a>
			<a href="http://jigsaw.w3.org/css-validator/"><img src="images/valid-css.png" alt="Valid CSS!" width="88" height="31" border="0"> </a>
		</td></tr></table></div></body></html>