<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Sun Jun 18 22:26:32 PDT 2006 -->
<TITLE>
BinaryXMLCodec (Nux 1.6 - API Specification)
</TITLE>

<META NAME="keywords" CONTENT="nux.xom.binary.BinaryXMLCodec class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="BinaryXMLCodec (Nux 1.6 - API Specification)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BinaryXMLCodec.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Nux 1.6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../nux/xom/binary/NodeBuilder.html" title="class in nux.xom.binary"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?nux/xom/binary/BinaryXMLCodec.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BinaryXMLCodec.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
nux.xom.binary</FONT>
<BR>
Class BinaryXMLCodec</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>nux.xom.binary.BinaryXMLCodec</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>BinaryXMLCodec</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>
</PRE>

<P>
Serializes (encodes) and deserializes (decodes) XOM XML documents to and from
 an efficient and compact custom binary XML data format (termed <i>bnux </i>
 format), without loss or change of any information. Serialization and
 deserialization is much faster than with the standard textual XML format, and
 the resulting binary data is more compressed than textual XML.
 
 <h4>Applicability</h4>
 
 The overall goal of the <i>bnux algorithm</i> is to maximize serialization
 and deserialization (parsing) performance without requiring any schema
 description. Serialization and deserialization speed are roughly balanced
 against each other; neither side is particularly favoured over the other.
 Another benefitial effect of the algorithm is that a considerable degree of
 XML data redundancy is eliminated, but compression is more a welcome
 side-effect than a primary goal in itself. The algorithm is primarily
 intended for tightly coupled high-performance systems exchanging large
 volumes of XML data over networks, as well as for compact main memory caches
 and for <i>short-term </i> storage as BLOBs in backend databases or files
 (e.g. "session" data with limited duration). In the case of BLOB storage,
 selecting matching BLOBs can be sped up by maintaining a simple metaindex
 side table for the most frequent access patterns. See the <a
 href="#performance">performance results</a> below.
 <p>
 While the Java API is considered stable, the bnux data format should be
 considered a black box: Its internals are under-documented and may change
 without notice from release to release in backwards-incompatible manners. It
 is unlikely that support for reading data written with older Nux versions
 will ever be available. bnux is an exchange format but not an
 interoperability format. Having said that, the data format is machine
 architecture/platform independent. For example a bnux file can be moved back
 and forth between a 32 bit Intel little-endian machine and a 64 bit PowerPC
 big-endian machine; it remains parseable no matter where.
 <p>
 This approach is expressly <b>not intended </b>as a replacement for standard
 textual XML in loosely coupled systems where maximum long-term
 interoperability is the overarching concern. It is also expressly <b>not
 intended </b>for long-term data storage. If you store data in bnux format
 there's every chance you won't be able to read it back a year or two from
 now, or even earlier. Finally, it is probably unwise to use this class if
 your application's performance requirements are not particularly stringent,
 or profiling indicates that the bottleneck is not related to XML
 serialization/deserialization anyway.
 <p>
 The bnux serialization algorithm is a fully streaming block-oriented
 algorithm, ideal for large numbers of very small to arbitrarily large 
 XML documents.
 <p>
 The bnux deserialization algorithm is a fully streaming algorithm and can
 optionally be pushed through a <A HREF="http://www.xom.nu/apidocs/nu/xom/NodeFactory.html" title="class or interface in nu.xom"><CODE>NodeFactory</CODE></A>. This enables
 efficient filtering and can avoid the need to build a main memory tree, which
 is particularly useful for arbitrarily large documents. For example, streaming 
 XQueries over binary XML can be expressed via the NodeFactory generated by a
 <A HREF="../../../nux/xom/xquery/StreamingPathFilter.html" title="class in nux.xom.xquery"><CODE>StreamingPathFilter</CODE></A>. In streaming mode, the binary
 codec exactly mimics the NodeFactory based behaviour of the XOM
 <A HREF="http://www.xom.nu/apidocs/nu/xom/Builder.html" title="class or interface in nu.xom"><CODE>Builder</CODE></A>.
 
 <h4>Faithfully Preversing XML</h4>
 
 Any and all arbitrary XOM XML documents are supported, and no schema is
 required. A XOM document that is serialized and subsequently deserialized by
 this class is <i>exactly the same </i> as the original document, preserving
 "as is" all names and data for elements, namespaces, additional namespace
 declarations, attributes, texts, document type, comments, processing
 instructions, whitespace, Unicode characters including surrogates, etc. As a
 result, the W3C XML Infoset and the W3C Canonical XML representation is
 guaranteed to be preserved. In particular there always holds:
 
 <pre>
 java.util.Arrays.equals(XOMUtil.toCanonicalXML(doc), XOMUtil
                .toCanonicalXML(deserialize(serialize(doc))));
 </pre>
 
 <h4>Optional ZLIB Compression</h4>
 
 The bnux algorithm considerably compresses XML data with little CPU
 consumption, by its very design. However, bnux also has an option to further
 compress/decompress its output/input with the ZLIB compression algorithm.
 ZLIB is based on Huffman coding and also used by the popular
 <code>gzip</code> (e.g. <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/util/zip/Deflater.html" title="class or interface in java.util.zip"><CODE>Deflater</CODE></A>). ZLIB compression
 is rather CPU intensive, but it typically yields strong compression factors,
 in particular for documents containing mostly narrative text (e.g. the
 bible). For example, strong compression may be desirable over low-bandwith
 networks or when bnux data is known to be accessed rather infrequently. On
 the other hand, ZLIB compression probably kills performance in the presence
 of high-bandwidth networks such as ESnet, Internet2/Abilene or 10 Gigabit
 Ethernet/InfiniBand LANs, even with high-end CPUs. CPU drain is also a
 scalability problem in the presence of large amounts of concurrent
 connections. An option ranging from 0 (no ZLIB compression; best performance)
 to 1 (little ZLIB compression; reduced performance) to 9 (strongest ZLIB
 compression; worst performance) allows one to configure the CPU/memory
 consumption trade-off.
 
 <h4>Reliability</h4>
 
 This class has been successfully tested against some 50000 extremely
 weird and unique test documents, including the W3C XML conformance test
 suite, and no bugs are known.
 <p>
 Serialization employs no error checking at all, since malformed XOM input
 documents are impossible to produce given XOM's design: XOM strictly enforces
 wellformedness anyway. Deserialization employs some limited error checking,
 throwing exceptions for any improper API usage, non-bnux input data, data
 format version mismatch, or general binary data corruption. Beyond this,
 deserialization relies on XOM's hard-wired wellformedness checks, just like
 serialization does. Barring one of the above catastrophic situations, the
 bnux algorithm will always correctly and faithfully reconstruct the exact
 same well-formed XOM document.
 
 <h4>Example Usage:</h4>
 
 <pre>
 // parse standard textual XML, convert to binary format, round-trip it and compare results
 Document doc = new Builder().build(new File("samples/data/periodic.xml"));
 BinaryXMLCodec codec = new BinaryXMLCodec();
 byte[] bnuxDoc = codec.serialize(doc, 0);
 Document doc2 = codec.deserialize(bnuxDoc);
 boolean isEqual = java.util.Arrays.equals(
     XOMUtil.toCanonicalXML(doc), XOMUtil.toCanonicalXML(doc2));
 System.out.println("isEqual = " + isEqual);
 System.out.println(doc2.toXML());
 
 // write binary XML document to file
 OutputStream out = new FileOutputStream("/tmp/periodic.xml.bnux");
 out.write(bnuxDoc);
 out.close();
 
 // read binary XML document from file
 bnuxDoc = FileUtil.toByteArray(new FileInputStream("/tmp/periodic.xml.bnux"));
 Document doc3 = codec.deserialize(bnuxDoc);
 System.out.println(doc3.toXML());
 </pre>
 
 <a name="performance"/>
 <h4>Performance</h4>
 
 This class has been carefully profiled and optimized. Preliminary performance
 results over a wide range of real-world documents are given below. A more
 detailed presentation can be found at the Global Grid Forum <a
 target="_blank"
 href="http://www.ggf.org/GGF15/ggf_events_schedule_WSPerform.htm">Web
 Services Performance Workshop</a>.
 <p>
 Contrasting bnux BinaryXMLCodec with the XOM Builder and Serializer:
 <ul>
 <li>Tree Deserialization speedup: 40-100 MB/s vs. 3-30 MB/s</li>
 <li>Streaming Deserialization speedup: 60-500 MB/s vs. 3-30 MB/s</li>
 <li>Tree Serialization speedup: 50-150 MB/s vs. 5-20 MB/s</li>
 <li>Data compression factor: 1.0 - 4</li>
 </ul>
 For meaningful comparison, MB/s and compression factors are always given
 normalized in relation to the original standard textual XML file size.
 <ul>
 <li>Benchmark test data: A wide variety of small to medium large XML
 documents is used, including SOAP documents heavily using namespaces ( <a
 target="_blank" href="http://xbis.sourceforge.net/">XBIS </a>), simple XML
 formatted web server logs using no namespaces, RDF documents with lots of
 attributes and namespaces, the periodic table, documents consisting of large
 narrative text ( <a target="_blank"
 href="http://www.oasis-open.org/cover/bosakShakespeare200.html">Shakespeare
 </a>), publication citations ( <a target="_blank"
 href="http://dblp.uni-trier.de/xml/">DBLP </a>), music title databases ( <a
 target="_blank" href="http://www.freedb.org/">FreeDB </a>), Japanese
 documents (XML conformance test suite), SVG image files, etc.</li>
 
 <li>Benchmark configuration: no ZLIB compression, xom-1.2, non-validating
 XOM Builder using xerces-2.8.0, no DTD or schema, Sun JDK 1.5.0 server VM,
 commodity PC 2004, Dual Pentium 4, 3.4 GHz, Redhat 9</li>
 </ul>
 
 Example Interpretation:
 <ul>
 <li>Small documents: Results translate, for example, to ping-pong
 round-tripping of typical 500 byte SOAP request/response message documents at
 a rate of 25000 msg/s, compared to 2500 msg/s with XOM (excluding network
 latency). More pronounced, 500 (150) byte documents with few namespaces
 translate to 35000 (120000) msg/s, compared to 3500 (5000) msg/s with XOM.
 Consequently, XML serialization and deserialization are probably nomore your
 application's bottleneck, leaving, say, 95% CPU headroom free for other
 application modules.</li>
 
 <li>Medium documents: When having a main-memory cache of several thousand 1
 MB documents, each containing highly structured complex data, one can
 deserialize, XQuery and serve from the cache at a rate of 50 documents/s,
 compared to 5 documents/s with XOM.</li>
 
 </ul>
 Note that in contrast to other algorithms, these measurements include XOM
 tree building and walking, hence measures delivering data to and from actual
 XML applications, rather than merely to and from a low-level SAX event stream
 (which is considerably cheaper and deemed less useful).
 <p>
 The deserialization speedup is further multiplied when DTDs or schema
 validation is used while parsing standard textual XML.
 <p>
 This class relies on advanced Java compiler optimizations, which take
 considerable time to warm up. Hence, for comparative benchmarks, use a
 server-class VM and make sure to repeat runs for at least 30 seconds.
 <p>
 Further, you will probably want to eliminate drastic XOM hotspots by
 compiling XOM with "ant -Dfat=true jar" to maintain an internal String
 instead of an UTF-8 encoded byte array in <A HREF="http://www.xom.nu/apidocs/nu/xom/Text.html" title="class or interface in nu.xom"><CODE>Text</CODE></A>, which
 eliminates the expensive character conversions implied for each access to a
 Text object. This increases performance at the expense of memory footprint.
 The measurements above report numbers using these patches, both for xom and
 bnux. If you're curious about the whereabouts of bottlenecks, run java with
 the non-perturbing '-server -agentlib:hprof=cpu=samples,depth=10' flags, then
 study the trace log and correlate its hotspot trailer with its call stack
 headers (see <a target="_blank"
 href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">
 hprof tracing </a>).
 <p>
 Use class <A HREF="../../../nux/xom/sandbox/BinaryXMLTest.html" title="class in nux.xom.sandbox"><CODE>BinaryXMLTest</CODE></A> to reproduce results, verify
 correctness or to evaluate performance for your own datasets.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>whoschek.AT.lbl.DOT.gov, $Author: hoschek $</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#BinaryXMLCodec()">BinaryXMLCodec</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an instance; An instance can be reused serially, but is not
 thread-safe, just like a <A HREF="http://www.xom.nu/apidocs/nu/xom/Builder.html" title="class or interface in nu.xom"><CODE>Builder</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../nux/xom/io/StreamingSerializer.html" title="interface in nux.xom.io">StreamingSerializer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#createStreamingSerializer(java.io.OutputStream, int)">createStreamingSerializer</A></B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/OutputStream.html" title="class or interface in java.io">OutputStream</A>&nbsp;out,
                          int&nbsp;zlibCompressionLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new streaming serializer that serializes bnux binary XML to
 the given underlying output stream, using the given ZLIB compression
 level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#deserialize(byte[])">deserialize</A></B>(byte[]&nbsp;bnuxDocument)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to
 <code>deserialize(new ByteArrayInputStream(input), new NodeFactory())</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#deserialize(java.io.InputStream, nu.xom.NodeFactory)">deserialize</A></B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/InputStream.html" title="class or interface in java.io">InputStream</A>&nbsp;input,
            <A HREF="http://www.xom.nu/apidocs/nu/xom/NodeFactory.html" title="class or interface in nu.xom">NodeFactory</A>&nbsp;factory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the XOM document obtained by deserializing the next binary XML
 document from the given input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#isBnuxDocument(java.io.InputStream)">isBnuxDocument</A></B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/InputStream.html" title="class or interface in java.io">InputStream</A>&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not the given input stream contains a bnux document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#serialize(nu.xom.Document, int)">serialize</A></B>(<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A>&nbsp;document,
          int&nbsp;zlibCompressionLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bnux binary XML document obtained by serializing the given
 XOM document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../nux/xom/binary/BinaryXMLCodec.html#serialize(nu.xom.Document, int, java.io.OutputStream)">serialize</A></B>(<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A>&nbsp;document,
          int&nbsp;zlibCompressionLevel,
          <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/OutputStream.html" title="class or interface in java.io">OutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serializes the given XOM document as a bnux binary XML document onto 
 the given output stream.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BinaryXMLCodec()"><!-- --></A><H3>
BinaryXMLCodec</H3>
<PRE>
public <B>BinaryXMLCodec</B>()</PRE>
<DL>
<DD>Constructs an instance; An instance can be reused serially, but is not
 thread-safe, just like a <A HREF="http://www.xom.nu/apidocs/nu/xom/Builder.html" title="class or interface in nu.xom"><CODE>Builder</CODE></A>.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createStreamingSerializer(java.io.OutputStream, int)"><!-- --></A><H3>
createStreamingSerializer</H3>
<PRE>
public <A HREF="../../../nux/xom/io/StreamingSerializer.html" title="interface in nux.xom.io">StreamingSerializer</A> <B>createStreamingSerializer</B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/OutputStream.html" title="class or interface in java.io">OutputStream</A>&nbsp;out,
                                                     int&nbsp;zlibCompressionLevel)</PRE>
<DL>
<DD>Constructs a new streaming serializer that serializes bnux binary XML to
 the given underlying output stream, using the given ZLIB compression
 level.
 <p>
 An optional zlib compression level ranging from 0 (no ZLIB compression;
 best performance) to 1 (little ZLIB compression; reduced performance) to
 9 (strongest ZLIB compression; worst performance) allows one to configure
 the CPU/memory consumption trade-off.
 <p>
 Unless there is a good reason to the contrary, you should always use
 level 0: the bnux algorithm typically already precompresses considerably.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - the underlying output stream to write to<DD><CODE>zlibCompressionLevel</CODE> - a number in the range 0..9
<DT><B>Returns:</B><DD>a streaming serializer</DL>
</DD>
</DL>
<HR>

<A NAME="isBnuxDocument(java.io.InputStream)"><!-- --></A><H3>
isBnuxDocument</H3>
<PRE>
public boolean <B>isBnuxDocument</B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/InputStream.html" title="class or interface in java.io">InputStream</A>&nbsp;input)
                       throws <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Returns whether or not the given input stream contains a bnux document.
 <p>
 A peek into the first 4 bytes is sufficient for unambigous detection, as
 standard textual XML cannot start with any arbitrary four byte
 combination.
 <p>
 Finally, the read bytes are put back onto the stream, so they can be
 reread as part of subsequent parsing attempts. Therefore, the input
 stream must support <code>input.mark()</code> and
 <code>input.reset()</code>. For example, a
 <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/BufferedInputStream.html" title="class or interface in java.io"><CODE>BufferedInputStream</CODE></A> is a good choice.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the stream to read from
<DT><B>Returns:</B><DD>true if the stream contains a bnux document
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the underlying stream does not support
             <code>input.mark()</code> and <code>input.reset()</code>.
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></CODE> - if the underlying input stream encounters an I/O error<DT><B>See Also:</B><DD><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/InputStream.html#mark(int)" title="class or interface in java.io"><CODE>InputStream.mark(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deserialize(byte[])"><!-- --></A><H3>
deserialize</H3>
<PRE>
public <A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A> <B>deserialize</B>(byte[]&nbsp;bnuxDocument)
                     throws <A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary">BinaryParsingException</A></PRE>
<DL>
<DD>Equivalent to
 <code>deserialize(new ByteArrayInputStream(input), new NodeFactory())</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bnuxDocument</CODE> - the bnux document to deserialize.
<DT><B>Returns:</B><DD>the new XOM document obtained from deserialization.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary">BinaryParsingException</A></CODE> - if the bnux document is unreadable or corrupt for some reason</DL>
</DD>
</DL>
<HR>

<A NAME="deserialize(java.io.InputStream, nu.xom.NodeFactory)"><!-- --></A><H3>
deserialize</H3>
<PRE>
public <A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A> <B>deserialize</B>(<A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/InputStream.html" title="class or interface in java.io">InputStream</A>&nbsp;input,
                            <A HREF="http://www.xom.nu/apidocs/nu/xom/NodeFactory.html" title="class or interface in nu.xom">NodeFactory</A>&nbsp;factory)
                     throws <A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary">BinaryParsingException</A>,
                            <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Returns the XOM document obtained by deserializing the next binary XML
 document from the given input stream.
 <p>
 If the document is in ZLIB compressed bnux format, it will be
 auto-detected and auto-decompressed as part of deserialization.
 <p>
 This method exactly mimics the NodeFactory based behaviour of the XOM
 <A HREF="http://www.xom.nu/apidocs/nu/xom/Builder.html" title="class or interface in nu.xom"><CODE>Builder</CODE></A>. A NodeFactory enables efficient filtering and
 can avoid the need to build a main memory tree, which is particularly
 useful for large documents. For example, streaming XQueries over binary
 XML can be expressed via the NodeFactory generated by a
 <A HREF="../../../nux/xom/xquery/StreamingPathFilter.html" title="class in nux.xom.xquery"><CODE>StreamingPathFilter</CODE></A>. Binary XML files can be
 converted to and from standard textual XML files via a
 <A HREF="../../../nux/xom/pool/XOMUtil.html#getRedirectingNodeFactory(nux.xom.io.StreamingSerializer)"><CODE>XOMUtil.getRedirectingNodeFactory(StreamingSerializer)</CODE></A>. For
 other example factories, see <A HREF="../../../nux/xom/pool/XOMUtil.html" title="class in nux.xom.pool"><CODE>XOMUtil</CODE></A>.
 <p>
 Bnux is a self-framing data format: It knows where the end of a document
 occurs. An input stream can contain any number of independent documents,
 one after another. Thus, this method reads from the stream as many bytes
 as required for the current document, but no more than that. Unlike SAX
 XML parsers and unlike a <A HREF="http://www.xom.nu/apidocs/nu/xom/Builder.html" title="class or interface in nu.xom"><CODE>Builder</CODE></A>, it does not read until
 end-of-stream (EOS), and it does not auto-close the input stream. If this
 method returns successfully, the input stream has been positioned one
 byte past the current bnux document, ready to deserialize the following
 document, if any. It is the responsibility of the caller to ensure the
 input stream gets properly closed when deemed appropriate.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the stream to read and deserialize from<DD><CODE>factory</CODE> - the node factory to stream into. May be <code>null</code> in
            which case the default XOM NodeFactory is used, building the
            complete XML document tree.
<DT><B>Returns:</B><DD>the new XOM document obtained from deserialization.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary">BinaryParsingException</A></CODE> - if the bnux document is unreadable or corrupt for some reason
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></CODE> - if the underlying input stream encounters an I/O error</DL>
</DD>
</DL>
<HR>

<A NAME="serialize(nu.xom.Document, int)"><!-- --></A><H3>
serialize</H3>
<PRE>
public byte[] <B>serialize</B>(<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A>&nbsp;document,
                        int&nbsp;zlibCompressionLevel)
                 throws <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></PRE>
<DL>
<DD>Returns the bnux binary XML document obtained by serializing the given
 XOM document.
 <p>
 An optional zlib compression level ranging from 0 (no ZLIB compression;
 best performance) to 1 (little ZLIB compression; reduced performance) to
 9 (strongest ZLIB compression; worst performance) allows one to configure
 the CPU/memory consumption trade-off.
 <p>
 Unless there is a good reason to the contrary, you should always use
 level 0: the bnux algorithm typically already precompresses considerably.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>document</CODE> - the XOM document to serialize<DD><CODE>zlibCompressionLevel</CODE> - a number in the range 0..9
<DT><B>Returns:</B><DD>the bnux document obtained from serialization.
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the compression level is out of range.</DL>
</DD>
</DL>
<HR>

<A NAME="serialize(nu.xom.Document, int, java.io.OutputStream)"><!-- --></A><H3>
serialize</H3>
<PRE>
public void <B>serialize</B>(<A HREF="http://www.xom.nu/apidocs/nu/xom/Document.html" title="class or interface in nu.xom">Document</A>&nbsp;document,
                      int&nbsp;zlibCompressionLevel,
                      <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/OutputStream.html" title="class or interface in java.io">OutputStream</A>&nbsp;out)
               throws <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A>,
                      <A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Serializes the given XOM document as a bnux binary XML document onto 
 the given output stream.
 <p>
 An optional zlib compression level ranging from 0 (no ZLIB compression;
 best performance) to 1 (little ZLIB compression; reduced performance) to
 9 (strongest ZLIB compression; worst performance) allows one to configure
 the CPU/memory consumption trade-off.
 <p>
 Unless there is a good reason to the contrary, you should always use
 level 0: the bnux algorithm typically already precompresses considerably.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>document</CODE> - the XOM document to serialize<DD><CODE>zlibCompressionLevel</CODE> - a number in the range 0..9<DD><CODE>out</CODE> - the output stream to write to
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the compression level is out of range.
<DD><CODE><A HREF="http://java.sun.com/j2se/1.4/docs/api/java/io/IOException.html" title="class or interface in java.io">IOException</A></CODE> - if the underlying output stream encounters an I/O error</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BinaryXMLCodec.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Nux 1.6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../nux/xom/binary/BinaryParsingException.html" title="class in nux.xom.binary"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../nux/xom/binary/NodeBuilder.html" title="class in nux.xom.binary"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?nux/xom/binary/BinaryXMLCodec.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BinaryXMLCodec.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
